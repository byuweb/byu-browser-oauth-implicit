const LEVEL_TRACE={priority:0,name:"trace",run:handleTrace},LEVEL_DEBUG={priority:1,name:"debug",run:handleDebug},LEVEL_INFO={priority:10,name:"info",run:handleInfo},LEVEL_ERROR={priority:100,name:"error",run:handleError},ALL_LEVELS=[LEVEL_TRACE,LEVEL_DEBUG,LEVEL_INFO,LEVEL_ERROR],DEFAULT_LEVEL=LEVEL_INFO;function debug(...a){log(LEVEL_DEBUG,...a)}function info(...a){log(LEVEL_INFO,...a)}function error(...a){log(LEVEL_ERROR,...a)}function debugf(a,...b){logf(LEVEL_DEBUG,a,...b)}function infof(a,...b){logf(LEVEL_INFO,a,...b)}function logf(a,b,...c){shouldLog(a)&&a.run(`[byu-browser-oauth-implicit] [${a.name}] (${getFormattedTime()}) ${b}`,...c)}function log(a,...b){shouldLog(a)&&a.run("[byu-browser-oauth-implicit]",`[${a.name}]`,`(${getFormattedTime()})`,...b)}function getFormattedTime(){const a=new Date,b=(a.getHours()+"").padStart(2,"0"),c=(a.getMinutes()+"").padStart(2,"0"),d=(a.getSeconds()+"").padStart(2,"0"),e=(a.getMilliseconds()+"").padStart(3,"0");return`${b}:${c}:${d},${e}${formatTimezone(a)}`}function formatTimezone(a){const b=a.getTimezoneOffset();if(0===b)return"Z";const c=Math.abs(b),d=Math.floor(c/60),e=(d+"").padStart(2,"0"),f=0<=b?"+":"-",g=(c%60+"").padStart(2,"0");return`${f}${e}${g}`}function shouldLog(a){return a.priority>=currentLevel().priority}function currentLevel(){const a=levelAttr()||levelGlobalVar();if(!a)return DEFAULT_LEVEL;const b=a.toLowerCase();return ALL_LEVELS.find(function(a){return a.name===b})||DEFAULT_LEVEL}function levelAttr(){return document.documentElement.getAttribute("byu-oauth-logging")}function levelGlobalVar(){const a=window.byuOAuth||{};return a.logging}function handleTrace(...a){console.trace?console.trace(...a):console.log(...a)}function handleDebug(...a){console.log(...a)}function handleInfo(...a){console.info?console.info(...a):console.log(...a)}function handleError(...a){console.error?console.error(...a):console.log(...a)}const EVENT_PREFIX="byu-browser-oauth",EVENT_STATE_CHANGE=`${"byu-browser-oauth"}-state-changed`,EVENT_LOGIN_REQUESTED=`${"byu-browser-oauth"}-login-requested`,EVENT_LOGOUT_REQUESTED=`${"byu-browser-oauth"}-logout-requested`,EVENT_REFRESH_REQUESTED=`${"byu-browser-oauth"}-refresh-requested`,EVENT_CURRENT_INFO_REQUESTED=`${"byu-browser-oauth"}-current-info-requested`,STATE_INDETERMINATE="indeterminate",STATE_UNAUTHENTICATED="unauthenticated",STATE_AUTHENTICATED="authenticated",STATE_AUTHENTICATING="authenticating",STATE_REFRESHING="refreshing",STATE_EXPIRED="expired",STATE_ERROR="error";/*
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */function parseHash(a){if(debug("parsing hash",a),!a)return new Map;let b=a;a.startsWith("#")&&(b=a.substr(1));const c=b.split("&").map(function(a){return a.split("=",2)});return new Map(c)}function unwrapExports(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a["default"]:a}function createCommonjsModule(a,b){return b={exports:{}},a(b,b.exports),b.exports}/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module exports.
 * @public
 */var parse_1=parse,serialize_1=serialize,decode=decodeURIComponent,encode=encodeURIComponent,pairSplitRegExp=/; */,fieldContentRegExp=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */function parse(a,b){if("string"!=typeof a)throw new TypeError("argument str must be a string");for(var c={},d=b||{},e=a.split(pairSplitRegExp),f=d.decode||decode,g=0;g<e.length;g++){var h=e[g],j=h.indexOf("=");// skip things that don't look like key=value
if(!(0>j)){var k=h.substr(0,j).trim(),l=h.substr(++j,h.length).trim();"\""==l[0]&&(l=l.slice(1,-1)),null==c[k]&&(c[k]=tryDecode(l,f))}}return c}/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */function serialize(a,b,c){var d=Math.floor,e=c||{},f=e.encode||encode;if("function"!=typeof f)throw new TypeError("option encode is invalid");if(!fieldContentRegExp.test(a))throw new TypeError("argument name is invalid");var g=f(b);if(g&&!fieldContentRegExp.test(g))throw new TypeError("argument val is invalid");var h=a+"="+g;if(null!=e.maxAge){var i=e.maxAge-0;if(isNaN(i))throw new Error("maxAge should be a Number");h+="; Max-Age="+d(i)}if(e.domain){if(!fieldContentRegExp.test(e.domain))throw new TypeError("option domain is invalid");h+="; Domain="+e.domain}if(e.path){if(!fieldContentRegExp.test(e.path))throw new TypeError("option path is invalid");h+="; Path="+e.path}if(e.expires){if("function"!=typeof e.expires.toUTCString)throw new TypeError("option expires is invalid");h+="; Expires="+e.expires.toUTCString()}if(e.httpOnly&&(h+="; HttpOnly"),e.secure&&(h+="; Secure"),e.sameSite){var j="string"==typeof e.sameSite?e.sameSite.toLowerCase():e.sameSite;switch(j){case!0:h+="; SameSite=Strict";break;case"lax":h+="; SameSite=Lax";break;case"strict":h+="; SameSite=Strict";break;default:throw new TypeError("option sameSite is invalid");}}return h}/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */function tryDecode(a,b){try{return b(a)}catch(b){return a}}var cookie={parse:parse_1,serialize:serialize_1},CookieStorage_1=createCommonjsModule(function(a,b){function c(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(b,"__esModule",{value:!0});var d=function(){function a(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}();b.hasCookies=function(){var a=new g;try{a.setItem("__test","1");var b=a.getItem("__test");return a.removeItem("__test"),"1"===b}catch(a){return!1}};var e=function(a){return a&&a.__esModule?a:{default:a}}(cookie),f="lS_",g=function(){function a(){var b=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};c(this,a),this.cookieOptions=Object.assign({path:"/"},b),f=void 0===b.prefix?f:b.prefix}return d(a,[{key:"getItem",value:function(a){var b=e.default.parse(document.cookie);return b&&b.hasOwnProperty(f+a)?b[f+a]:null}},{key:"setItem",value:function(a,b){return document.cookie=e.default.serialize(f+a,b,this.cookieOptions),b}},{key:"removeItem",value:function(a){var b=Object.assign({},this.cookieOptions,{maxAge:-1});return document.cookie=e.default.serialize(f+a,"",b),null}},{key:"clear",value:function(){var a=e.default.parse(document.cookie);for(var b in a)0===b.indexOf(f)&&this.removeItem(b.substr(f.length));return null}}]),a}();b.default=g});unwrapExports(CookieStorage_1);var CookieStorage_2=CookieStorage_1.hasCookies,isSupported_1=createCommonjsModule(function(a,b){function c(a){try{var b=window[a];return b.setItem("__test","1"),b.removeItem("__test"),!0}catch(a){return!1}}Object.defineProperty(b,"__esModule",{value:!0}),b.default=function(){var a=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"localStorage",b=(a+"").replace(/storage$/i,"").toLowerCase();if("local"===b)return c("localStorage");if("session"===b)return c("sessionStorage");if("cookie"===b)return(0,CookieStorage_1.hasCookies)();if("memory"===b)return!0;throw new Error("Storage method `"+a+"` is not available.\n    Please use one of the following: localStorage, sessionStorage, cookieStorage, memoryStorage.")}});unwrapExports(isSupported_1);var MemoryStorage_1=createCommonjsModule(function(a,b){function c(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(b,"__esModule",{value:!0});var d=function(){function a(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}(),e=function(){function a(){c(this,a),this._data={}}return d(a,[{key:"getItem",value:function(a){return this._data.hasOwnProperty(a)?this._data[a]:null}},{key:"setItem",value:function(a,b){return this._data[a]=b+""}},{key:"removeItem",value:function(a){return delete this._data[a]}},{key:"clear",value:function(){return this._data={}}}]),a}();b.default=e});unwrapExports(MemoryStorage_1);var lib=createCommonjsModule(function(a,b){function c(a){return a&&a.__esModule?a:{default:a}}Object.defineProperty(b,"__esModule",{value:!0}),b.MemoryStorage=b.CookieStorage=b.isSupported=b.storage=void 0;var d=c(isSupported_1),e=c(CookieStorage_1),f=c(MemoryStorage_1),g=null;b.storage=(0,d.default)("localStorage")?g=window.localStorage:(0,d.default)("sessionStorage")?g=window.sessionStorage:(0,d.default)("cookieStorage")?g=new e.default:g=new f.default,b.default=g,b.storage=g,b.isSupported=d.default,b.CookieStorage=e.default,b.MemoryStorage=f.default}),storage=unwrapExports(lib),lib_1=lib.MemoryStorage,lib_2=lib.CookieStorage,lib_3=lib.isSupported,lib_4=lib.storage;/*
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */class StorageHandler{saveOAuthState(a,b){storage.setItem(getKey(a),JSON.stringify(b))}getOAuthState(a){const b=storage.getItem(getKey(a));return b?JSON.parse(b):null}clearOAuthState(a){storage.removeItem(getKey(a))}saveSessionState(a,b){storage.setItem(getSessionKey(a),JSON.stringify(b))}getSessionState(a){const b=getSessionKey(a),c=storage.getItem(b);return c?JSON.parse(c):null}clearSessionState(a){storage.removeItem(getSessionKey(a))}}function getKey(a){return"oauth-state-"+encodeURIComponent(a)}function getSessionKey(a){return getKey(a)+"-active-session"}/*
 *  @license
 *    Copyright 2018 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */let SINGLETON_INSTANCE;const CHILD_IFRAME_ID="byu-oauth-implicit-grant-refresh-iframe",FIFTY_FIVE_MINUTES_MILLIS=33e5,STORED_STATE_LIFETIME=300000,IG_STATE_AUTO_REFRESH_FAILED="implicit-grant-auto-refresh-failed";class ImplicitGrantProvider{constructor(a,b,c,d=new StorageHandler){debug("initializing provider with config",a),this.config=a,this.window=b,this.document=c,this.storageHandler=d,this._listeners={},this.store=Object.freeze({state:STATE_INDETERMINATE,user:null,token:null,error:null}),debug("initialized provider")}_changeState(a,b,c,d){logStateChange(a,b,c,d),this.store=Object.freeze({state:a,user:b,token:c,error:d}),_dispatchEvent(this,EVENT_STATE_CHANGE,this.store)}// Separate state change listener, because state change events
// might come from child iframe/popup window
handleStateChange({state:a,user:b,token:c,source:d}){// If this is a popup
if(debug("in handleStateChange",a),this.window.opener)// We're inside a child re-authentication popup
return d?void 0:(debug("dispatching event to parent"),_dispatchEvent(this.window.opener,EVENT_STATE_CHANGE,{state:a,token:c,user:b,source:"popup"}),void(a===STATE_AUTHENTICATED&&(info("closing self"),this.window.close())));// If we're inside the "refresh" iframe
const e=this.window.parent.document.getElementById(CHILD_IFRAME_ID);return e?d?void 0:(debug("dispatching event to parent"),_dispatchEvent(this.window.parent,EVENT_STATE_CHANGE,{state:a,token:c,user:b,source:"iframe"}),void(a===STATE_AUTHENTICATED&&(info("removing child iframe"),e.parentNode.removeChild(e)))):void(this._maybeUpdateStoredSession(a,b,c),a===STATE_AUTHENTICATED&&this._checkExpired(c.expiresAt.getTime()))}async startup(){ensureOnlyInstance(this),info("starting up"),this.listen(),this._changeState(STATE_INDETERMINATE);const a=this._location,b=this._hashParams;if(this.isAuthenticationCallback(a.href,b)){debug("handling authentication callback"),this._changeState(STATE_AUTHENTICATING);try{const{state:c,user:d,token:e,error:f}=await _handleAuthenticationCallback(this.config,a,b,this.storageHandler);this._changeState(c,d,e,f)}catch(a){error("OAuth Error",a),this._changeState(STATE_ERROR,void 0,void 0,a)}}return this.hasStoredSession()?(debug("Has stored session"),this._updateStateFromStorage()):(debug("no authentication present"),this._changeState(STATE_UNAUTHENTICATED)),this}_checkExpired(a){var b=this;debug("checking expiration time");const c=a-Date.now(),d=0>c,e=c>FIFTY_FIVE_MINUTES_MILLIS;return d||e?void(this.config.autoRefreshOnTimeout?(e&&debug("silently refreshing token to work around odd identity server issue"),this._changeState(STATE_REFRESHING,this.store.user,this.store.token),this._schedulePeriodic(function(){return b.startRefresh("iframe")})):d&&this._changeState(STATE_EXPIRED,this.store.user,this.store.token)):void this._scheduleExpirationCheck(a)}_scheduleRefresh(){var a=this;return info("scheduling auto-refresh"),this.__refreshTask?void debug("refresh already scheduled"):this.__refreshTask=this._schedulePeriodic(function(){a.__refreshTask=null,a.startRefresh("iframe")})}_scheduleExpirationCheck(a){var b=this;return this.__expirationTask&&clearTimeout(this.__expirationTask),this.__expirationTask=this._schedulePeriodic(function(){b.__expirationTask=null,b._checkExpired(a)})}_schedulePeriodic(a){// Simply using setTimeout for an hour in the future
// doesn't work; setTimeout isn't that precise over that long of a period.
// So re-check every five seconds until we're past the expiration time
return setTimeout(a,5e3)}get _location(){return this.window.location}get _hashParams(){return parseHash(this._location.hash)}isAuthenticationCallback(a,b){const c=0===a.indexOf(this.config.callbackUrl),d=0!==b.size;return!!(c&&d)&&(b.has("access_token")||b.has("error"))}hasStoredSession(){return!!this.storageHandler.getSessionState(this.config.clientId)}shutdown(){info("shutting down"),this.unlisten(),this._changeState(STATE_INDETERMINATE),cleanupOnlyInstance()}listen(){debug("setting up event listeners"),_listenTo(this,EVENT_LOGIN_REQUESTED,this.startLogin),_listenTo(this,EVENT_LOGOUT_REQUESTED,this.startLogout),_listenTo(this,EVENT_REFRESH_REQUESTED,this.startRefresh),_listenTo(this,EVENT_CURRENT_INFO_REQUESTED,this.handleCurrentInfoRequest),_listenTo(this,EVENT_STATE_CHANGE,this.handleStateChange)}unlisten(){debug("tearing down event listeners"),_unlistenTo(this,EVENT_LOGIN_REQUESTED),_unlistenTo(this,EVENT_LOGOUT_REQUESTED),_unlistenTo(this,EVENT_REFRESH_REQUESTED),_unlistenTo(this,EVENT_CURRENT_INFO_REQUESTED),_unlistenTo(this,EVENT_STATE_CHANGE)}startLogin(a="window"){var b=this;infof("Starting login. mode=%s",a);const{clientId:c,callbackUrl:d}=this.config,e=randomString(),f=_prepareStoredState(Date.now()+STORED_STATE_LIFETIME,e,{});this.storageHandler.saveOAuthState(this.config.clientId,f);const g=`https://api.byu.edu/authorize?response_type=token&client_id=${c}&redirect_uri=${encodeURIComponent(d)}&scope=openid&state=${e}`;if(debug("computed login url of",g),!a||"window"==a)return info(`Redirecting user to '${g}'`),void(this.window.location=g);if("popup"===a)return info("launching popup at",g),void this.window.open(g);info("Setting up hidden refresh iframe at",g);// last option: displayType == 'iframe'
let h=this.document.getElementById(CHILD_IFRAME_ID);h&&h.parentNode.removeChild(h),h=this.document.createElement("iframe"),h.onload=function(){let a=null;try{a=h.contentWindow.document.body.innerHTML}catch(a){// intentional do-nothing
}null===a&&(h.parentNode.removeChild(h),b._changeState(IG_STATE_AUTO_REFRESH_FAILED,null,null))},h.id=CHILD_IFRAME_ID,h.src=g,h.style="display:none",debug("appending iframe",h),this.document.body.appendChild(h)}startLogout(){info("starting logout"),this.storageHandler.clearSessionState(this.config.clientId);const a="http://api.byu.edu/logout?redirect_url="+encodeURIComponent(this.config.callbackUrl);info("logging out by redirecting to",a),this.window.location=a}startRefresh(a="iframe"){infof("starting refresh. displayType=%s",a),this.startLogin(a)}handleCurrentInfoRequest({callback:a}){debug("got current info request"),a&&a(this.store)}_updateStateFromStorage(){debug("updating state from local storage");const a=this.storageHandler.getSessionState(this.config.clientId);if(!a)return debug("no stored state"),void this._changeState(STATE_UNAUTHENTICATED);const{user:b,token:c}=deserializeSessionState(a);b&&c?c.expiresAt>new Date?(debug("found an unexpired saved session"),this._changeState(STATE_AUTHENTICATED,b,c)):(debug("stored session was expired"),this._changeState(STATE_UNAUTHENTICATED)):(debug("no stored user or token"),this._changeState(STATE_UNAUTHENTICATED))}_maybeUpdateStoredSession(a,b,c){if(debugf("updating stored session: state=%s hasUser=%s, hasToken=%s",a,!!b,!!c),a===STATE_UNAUTHENTICATED)debug("state is unauthenticated, clearing stored session"),this.storageHandler.clearSessionState(this.config.clientId);else if(!!b&&!!c){debug("storing session",redactUser(b),redactToken(c));const a=serializeSessionState(b,c);this.storageHandler.saveSessionState(this.config.clientId,a)}}}function serializeSessionState(a,b){const c=groupClaimPrefixes(b.rawUserInfo),d={ro:c[CLAIMS_PREFIX_RESOURCE_OWNER],cl:c[CLAIMS_PREFIX_CLIENT],wso2:c[CLAIMS_PREFIX_WSO2],o:c.other};return{ui:d,at:b.bearer,ah:b.authorizationHeader,ea:b.expiresAt.getTime()}}function deserializeSessionState(a){const b={[CLAIMS_PREFIX_RESOURCE_OWNER]:a.ui.ro,[CLAIMS_PREFIX_CLIENT]:a.ui.cl,[CLAIMS_PREFIX_WSO2]:a.ui.wso2,other:a.ui.o},c=ungroupClaimPrefixes(b),d=_processUserInfo(c),e=new Date(a.ea),f=_processTokenInfo(c,a.at,e,`Bearer ${a.at}`);return{user:d,token:f}}function _listenTo(a,b,c){if(a._listeners.hasOwnProperty(b))throw new Error("A listener is already registered for "+b);const d=a._listeners[b]=function(b){c.call(a,b.detail)}.bind(a);a.document.addEventListener(b,d,!1)}function _unlistenTo(a,b){a._listeners.hasOwnProperty(b)&&(a.document.removeEventListener(b,a._listeners[b],!1),delete a._listeners[b])}function _dispatchEvent(a,b,c){let d;"function"==typeof a.window.CustomEvent?d=new CustomEvent(b,{detail:c}):(d=a.document.createEvent("CustomEvent"),d.initCustomEvent(b,!0,!1,c)),a.document.dispatchEvent(d)}async function _handleAuthenticationCallback(a,b,c,d){if(c.has("error"))throw error("Got oauth error in URL hash"),new OAuthError(c.get("error"),c.get("error_description"),c.get("error_uri"));const e=c.get("state"),f=d.getOAuthState(a.clientId);d.clearOAuthState(a.clientId),debug("checking oauth state token");const g=_validateAndGetStoredState(f,e),h=c.get("access_token"),i=+c.get("expires_in"),j=new Date(Date.now()+1e3*i),k=`Bearer ${h}`;debug("got token",redactBearerToken(h),"which expires in",i,"seconds");const l=await _fetchUserInfo(k),m=_processUserInfo(l),n=_processTokenInfo(l,h,j,k);return b.hash="",{state:STATE_AUTHENTICATED,user:m,token:n}}const USER_INFO_URL="https://api.byu.edu/openid-userinfo/v1/userinfo?schema=openid";async function _fetchUserInfo(a){debug("fetching user info from",USER_INFO_URL);const b=await fetch(USER_INFO_URL,{method:"GET",headers:new Headers({Accept:"application/json",Authorization:a}),mode:"cors"});if(debug("got status",b.status),200!==b.status){const a=await b.text();if(403===b.status)if(debug("got forbidden error"),a.includes("<ams:code>900908</ams:code>"))throw debug("client app isn't subscribed to OpenID UserInfo endpoint"),console.error(`DEVELOPER ERROR: You may not be subscribed to the OpenID UserInfo endpoint. Please visit https://api.byu.edu/store/apis/info?name=OpenID-Userinfo&version=v1&provider=BYU%2Fjmooreoa to subscribe.`),new OAuthError("not-subscribed-to-user-info","This page has an authentication configuration error. Developers, see the console for details.");else throw error("invalid oauth bearer token"),new OAuthError("invalid-oauth-token","The provided authentication token is invalid. Please try again.");throw console.error("Error getting OAuth User Info. Status Code:",b.status,"Response:\n",a),new OAuthError("unable-to-get-user-info","Unable to fetch user information. Please try again.")}const c=await b.json();return debug("successfully got user info",c),c}const CLAIMS_PREFIX_RESOURCE_OWNER="http://byu.edu/claims/resourceowner_",CLAIMS_PREFIX_CLIENT="http://byu.edu/claims/client_",CLAIMS_PREFIX_WSO2="http://wso2.org/claims/",CLAIMS_KNOWN_PREFIXES=[CLAIMS_PREFIX_CLIENT,"http://byu.edu/claims/resourceowner_",CLAIMS_PREFIX_WSO2];function groupClaimPrefixes(a){const b={other:{}};for(const c of CLAIMS_KNOWN_PREFIXES)b[c]={};for(const c of Object.keys(a)){const d=a[c],e=CLAIMS_KNOWN_PREFIXES.find(function(a){return c.startsWith(a)});e?b[e][c.substr(e.length)]=d:b.other[c]=d}return b}function ungroupClaimPrefixes(a){const b={};for(const c of CLAIMS_KNOWN_PREFIXES){const d=a[c];if(d)for(const a of Object.keys(d))b[c+a]=d[a]}for(const c of Object.keys(a.other))b[c]=a.other[c];return b}function getClaims(a,b){return Object.keys(a).filter(function(a){return a.startsWith(b)}).reduce(function(c,d){return c[d.substr(b.length)]=a[d],c},{})}function _processUserInfo(a){const b=getClaims(a,CLAIMS_PREFIX_RESOURCE_OWNER),c=b.surname_position,d=a.given_name,e=a.family_name,f="F"===c?`${e} ${d}`:`${d} ${e}`;return{personId:b.person_id,byuId:b.byu_id,netId:b.net_id,name:{sortName:b.sort_name,displayName:f,givenName:d,familyName:e,familyNamePosition:c},rawUserInfo:a}}function _processTokenInfo(a,b,c,d){const e=getClaims(a,CLAIMS_PREFIX_CLIENT),f=getClaims(a,CLAIMS_PREFIX_WSO2);return{bearer:b,authorizationHeader:d,expiresAt:c,client:{id:f.client_id,byuId:e.byu_id,appName:f.applicationname},rawUserInfo:a}}function _validateAndGetStoredState(a,b){if(debug("validating stored state token. Expecting token",b,", got state",a),!a)throw error("no stored oauth login state"),new OAuthError("no-oauth-state","Your saved authentication information does not match. Please try again.");const{e:c,c:d,s:e}=a;if(b!==d)throw error("CSRF token mismatch"),new OAuthError("oauth-state-mismatch","Your saved authentication information does not match. Please try again.");if(+c<Date.now())throw error("stored state has expired"),new OAuthError("oauth-state-expired","Your login attempt has timed out. Please try again.");return e}function _prepareStoredState(a,b,c){return{e:a,c:b,s:c}}class OAuthError extends Error{constructor(a,b,c){super("OAuth Error: "+b),this.type=a,this.description=b,this.uri=c}}function randomString(){let a=new Uint32Array(3);const b=window.crypto||window.msCrypto;return b.getRandomValues(a),a.reduce(function(a,b){return a+b.toString(16)},"")}function logStateChange(a,b,c,d){const e=["state change:",{state:a,user:redactUser(b),token:c,//redactToken(token),
error:d}];d?error(...e):info(...e)}function redactUser(a){return a?{netId:a.netId,"rest-is-redacted":!0}:void 0}function redactToken(a){if(console.log("redacting token",a),!!a){console.log(a);const{bearer:b,expiresAt:c,client:d}=a;return console.log(c),console.log(typeof c),{bearer:redactBearerToken(b),expiresAt:c?c.toISOString():null,client:d,"rest-is-redacted":!0}}}function redactBearerToken(a){return a?a.substring(0,2)+"...redacted..."+a.substring(a.length-2):void 0}function ensureOnlyInstance(a){if(SINGLETON_INSTANCE){const a=SINGLETON_INSTANCE.___startupTrace;throw new Error("There is already an instance of byu-oauth-implicit running!  Please call `#shutdown()` on that instance before starting a new one. Instance was started at:\n"+a)}a.___startupTrace=new Error().stack,SINGLETON_INSTANCE=a}function cleanupOnlyInstance(){SINGLETON_INSTANCE=null}/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const DEFAULT_ISSUER="https://api.byu.edu",GLOBAL_CONFIG_KEY="byu-oauth-implicit-config";/**
 * @typedef {} ImplicitConfig
 * @prop {string} clientId
 * @prop {?string} issuer
 * @prop {?string} callbackUrl
 * @prop {?boolean} requireAuthentication
 */ /**
 * @param {ImplicitConfig|ImplicitConfig[]} cfgOrRules
 * @param location
 */async function configure(a,b=window.location){const c=resolveConfig(a,b),d=window[GLOBAL_CONFIG_KEY],e=Object.assign({issuer:DEFAULT_ISSUER,callbackUrl:`${b.origin}${b.pathname}`,autoRefreshOnTimeout:!1},d,c);if(!e.clientId)throw new Error("clientId must be specified in config");const f=new ImplicitGrantProvider(e,window,document);return f.startup()}function resolveConfig(a,b){if("clientId"in a)return a;const c=Object.keys(a).filter(function(a){return a.startsWith("https://")||a.startsWith("http://")});if(0===c.length)return a;const d=c// order by length of key (most specific), descending
.sort(function(c,a){return a.length-c.length}).find(function(a){return b.href.startsWith(a)});if(d)return a[d];throw new Error(`Unable to match url [${b.href}] to one of [${c}]`)}export{DEFAULT_ISSUER,GLOBAL_CONFIG_KEY,configure};
//# sourceMappingURL=implicit-grant.min.js.map
